import * as vue_demi from 'vue-demi';
import { Ref, ComputedRef, WatchOptions, WatchSource, WatchCallback, WatchStopHandle, ShallowUnwrapRef as ShallowUnwrapRef$1, UnwrapRef } from 'vue-demi';
import { Fn as Fn$1 } from '@vueuse/shared';

declare const isClient: boolean;
declare const isDef: <T = any>(val?: T | undefined) => val is T;
declare const assert: (condition: boolean, ...infos: any[]) => void;
declare const isBoolean: (val: any) => val is boolean;
declare const isFunction: <T extends Function>(val: any) => val is T;
declare const isNumber: (val: any) => val is number;
declare const isString: (val: unknown) => val is string;
declare const isObject: (val: any) => val is object;
declare const isWindow: (val: any) => val is Window;
declare const now: () => number;
declare const timestamp: () => number;
declare const clamp: (n: number, min: number, max: number) => number;
declare const noop: () => void;

/**
 * Any function
 */
declare type Fn = () => void;
/**
 * Maybe it's a ref, or not.
 *
 * ```ts
 * type MaybeRef<T> = T | Ref<T>
 * ```
 */
declare type MaybeRef<T> = T | Ref<T> | ComputedRef<T>;
/**
 * Make all the nested attributes of an object or array to MaybeRef<T>
 *
 * Good for accepting options that will be wrapped with `reactive` or `ref`
 *
 * ```ts
 * UnwrapRef<DeepMaybeRef<T>> === T
 * ```
 */
declare type DeepMaybeRef<T> = T extends Ref<infer V> ? MaybeRef<V> : T extends Array<any> | object ? {
    [K in keyof T]: DeepMaybeRef<T[K]>;
} : MaybeRef<T>;
/**
 * Infers the element type of an array
 */
declare type ElementOf<T> = T extends (infer E)[] ? E : never;
declare type ShallowUnwrapRef<T> = T extends Ref<infer P> ? P : T;
interface Pausable {
    /**
     * A ref indicate whether a pusable instance is active
     */
    isActive: Ref<boolean>;
    /**
     * Temporary pause the effect from executing
     */
    pause: Fn;
    /**
     * Resume the effects
     */
    resume: Fn;
}
interface ConfigurableFlush {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details
     *
     * @default 'pre'
     */
    flush?: WatchOptions['flush'];
}
interface ConfigurableFlushSync {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details.
     * Unlike `watch()`, the default is set to `sync`
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
}
declare type MapSources<T> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? V : never;
};
declare type MapOldSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : never;
};

declare type FunctionArgs<Args extends any[] = any[], Return = void> = (...args: Args) => Return;
interface FunctionWrapperOptions<Args extends any[] = any[], This = any> {
    fn: FunctionArgs<Args, This>;
    args: Args;
    thisArg: This;
}
declare type EventFilter<Args extends any[] = any[], This = any> = (invoke: Fn, options: FunctionWrapperOptions<Args, This>) => void;
interface ConfigurableEventFilter {
    eventFilter?: EventFilter;
}
/**
 * @internal
 */
declare function createFilterWrapper<T extends FunctionArgs>(filter: EventFilter, fn: T): T;
declare const bypassFilter: EventFilter;
/**
 * Create an EventFilter that debounce the events
 *
 * @param ms
 */
declare function debounceFilter(ms: MaybeRef<number>): EventFilter<any[], any>;
/**
 * Create an EventFilter that throttle the events
 *
 * @param ms
 * @param [trailing=true]
 */
declare function throttleFilter(ms: MaybeRef<number>, trailing?: boolean): EventFilter<any[], any>;
/**
 * EventFilter that gives extra controls to pause and resume the filter
 *
 * @param extendFilter  Extra filter to apply when the PauseableFilter is active, default to none
 *
 */
declare function pausableFilter(extendFilter?: EventFilter): Pausable & {
    eventFilter: EventFilter;
};

declare function promiseTimeout(ms: number, throwOnTimeout?: boolean, reason?: string): Promise<void>;
interface SingletonPromiseReturn<T> {
    (): Promise<T>;
    /**
     * Reset current staled promise.
     * await it to have proper shutdown.
     */
    reset: () => Promise<void>;
}
/**
 * Create singleton promise function
 *
 * @example
 * ```
 * const promise = createSingletonPromise(async () => { ... })
 *
 * await promise()
 * await promise() // all of them will be bind to a single promise instance
 * await promise() // and be resolved together
 * ```
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): SingletonPromiseReturn<T>;
declare function invoke<T>(fn: () => T): T;
declare function containsProp(obj: object, ...props: string[]): boolean;
/**
 * Increase string a value with unit
 *
 * @example '2px' + 1 = '3px'
 * @example '15em' + (-2) = '13em'
 */
declare function increaseWithUnit(target: number, delta: number): number;
declare function increaseWithUnit(target: string, delta: number): string;
declare function increaseWithUnit(target: string | number, delta: number): string | number;

/**
 * `AND` conditions for refs.
 *
 * @link https://vueuse.org/and
 */
declare function and(...args: MaybeRef<any>[]): ComputedRef<boolean>;

/**
 * Two-way refs synchronization.
 *
 * @param a
 * @param b
 */
declare function biSyncRef<R extends Ref<any>>(a: R, b: R): () => void;

/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
declare function controlledComputed<T, S>(source: WatchSource<S>, fn: () => T): ComputedRef<T>;

interface ControlledRefOptions<T> {
    /**
     * Callback function before the ref changing.
     *
     * Returning `false` to dismiss the change.
     */
    onBeforeChange?: (value: T, oldValue: T) => void | boolean;
    /**
     * Callback function after the ref changed
     *
     * This happends synchronously, with less overhead compare to `watch`
     */
    onChanged?: (value: T, oldValue: T) => void;
}
/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
declare function controlledRef<T>(initial: T, options?: ControlledRefOptions<T>): vue_demi.ShallowUnwrapRef<{
    get: (tracking?: boolean) => T;
    set: (value: T, triggering?: boolean) => void;
    untrackedGet: () => T;
    silentSet: (v: T) => void;
    peek: () => T;
    lay: (v: T) => void;
}> & vue_demi.Ref<T>;

interface DebouncedWatchOptions<Immediate> extends WatchOptions<Immediate> {
    debounce?: MaybeRef<number>;
}
declare function debouncedWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;
declare function debouncedWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;
declare function debouncedWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: DebouncedWatchOptions<Immediate>): WatchStopHandle;

interface ExtendRefOptions<Unwrap extends boolean = boolean> {
    /**
     * Is the extends properties enumerable
     *
     * @default false
     */
    enumerable?: boolean;
    /**
     * Unwrap for Ref properties
     *
     * @default true
     */
    unwrap?: Unwrap;
}
/**
 * Overlad 1: Unwrap set to false
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions<false>>(ref: R, extend: Extend, options?: Options): ShallowUnwrapRef$1<Extend> & R;
/**
 * Overlad 2: Unwrap unset or set to true
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions>(ref: R, extend: Extend, options?: Options): Extend & R;

/**
 * Shorthand for accessing `ref.value`
 */
declare function get<T>(ref: MaybeRef<T>): T;
declare function get<T, K extends keyof T>(ref: MaybeRef<T>, key: K): T[K];

interface WatchWithFilterOptions<Immediate> extends WatchOptions<Immediate>, ConfigurableEventFilter {
}
declare function watchWithFilter<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;

declare type IgnoredUpdater = (updater: () => void) => void;
interface IgnorableWatchReturn {
    ignoreUpdates: IgnoredUpdater;
    ignorePrevAsyncUpdates: () => void;
    stop: WatchStopHandle;
}
declare function ignorableWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;
declare function ignorableWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;
declare function ignorableWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): IgnorableWatchReturn;

declare function makeDestructurable<T extends Record<string, unknown>, A extends readonly any[]>(obj: T, arr: A): T & A;

/**
 * `NOT` conditions for refs.
 *
 * @link https://vueuse.org/not
 */
declare function not(v: MaybeRef<any>): ComputedRef<boolean>;

/**
 * `OR` conditions for refs.
 *
 * @link https://vueuse.org/or
 */
declare function or(...args: MaybeRef<any>[]): ComputedRef<boolean>;

interface PausableWatchReturn extends Pausable {
    stop: WatchStopHandle;
}
declare function pausableWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;
declare function pausableWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;
declare function pausableWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): PausableWatchReturn;

declare type Reactify<T> = T extends (...args: infer A) => infer R ? (...args: {
    [K in keyof A]: MaybeRef<A[K]>;
}) => ComputedRef<R> : never;
/**
 * Converts plain function into a reactive function.
 * The converted function accepts refs as it's arguments
 * and returns a ComputedRef, with proper typing.
 *
 * @param fn - Source function
 */
declare function reactify<T extends Function>(fn: T): Reactify<T>;

declare type ReactifyNested<T, Keys extends keyof T = keyof T> = {
    [K in Keys]: T[K] extends (...args: any[]) => any ? Reactify<T[K]> : T[K];
};
interface ReactifyObjectOptions {
    /**
     * Includes names from Object.getOwnPropertyNames
     *
     * @default true
     */
    includeOwnProperties?: boolean;
}
/**
 * Apply `reactify` to an object
 */
declare function reactifyObject<T extends object, Keys extends keyof T>(obj: T, keys?: (keyof T)[]): ReactifyNested<T, Keys>;
declare function reactifyObject<T extends object>(obj: T, options?: ReactifyObjectOptions): ReactifyNested<T>;

/**
 * Reactively pick fields from a reactive object
 *
 * @link https://vueuse.js.org/reactivePick
 */
declare function reactivePick<T extends object, K extends keyof T>(obj: T, ...keys: K[]): {
    [S in K]: UnwrapRef<T[S]>;
};

declare function set<T>(ref: Ref<T>, value: T): void;
declare function set<O extends object, K extends keyof O>(target: O, key: K, value: O[K]): void;

interface SyncRefOptions extends ConfigurableFlushSync {
    /**
     * Watch deeply
     *
     * @default false
     */
    deep?: boolean;
    /**
     * Sync values immediately
     *
     * @default true
     */
    immediate?: boolean;
}
/**
 * Keep target ref(s) in sync with the source ref
 *
 * @param source source ref
 * @param targets
 */
declare function syncRef<R extends Ref<any>>(source: R, targets: R | R[], { flush, deep, immediate, }?: SyncRefOptions): vue_demi.WatchStopHandle;

interface ThrottledWatchOptions<Immediate> extends WatchOptions<Immediate> {
    throttle?: MaybeRef<number>;
}
declare function throttledWatch<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: T, cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;
declare function throttledWatch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;
declare function throttledWatch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: ThrottledWatchOptions<Immediate>): WatchStopHandle;

/**
 * Call onMounted() if it's inside a component lifecycle, if not, run just call the function
 *
 * @param fn
 * @param sync if set to false, it will run in the nextTick() of Vue
 */
declare function tryOnMounted(fn: Fn, sync?: boolean): void;

/**
 * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
declare function tryOnUnmounted(fn: Fn): void;

interface UntilToMatchOptions {
    /**
     * Milseconds timeout for promise to resolve/reject if the when condition does not meet.
     * 0 for never timed out
     *
     * @default 0
     */
    timeout?: number;
    /**
     * Reject the promise when timeout
     *
     * @default false
     */
    throwOnTimeout?: boolean;
    /**
     * `flush` option for internal watch
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
    /**
     * `deep` option for internal watch
     *
     * @default 'false'
     */
    deep?: WatchOptions['deep'];
}
interface UntilBaseInstance<T> {
    toMatch(condition: (v: T) => boolean, options?: UntilToMatchOptions): Promise<void>;
    changed(options?: UntilToMatchOptions): Promise<void>;
    changedTimes(n?: number, options?: UntilToMatchOptions): Promise<void>;
}
interface UntilValueInstance<T> extends UntilBaseInstance<T> {
    readonly not: UntilValueInstance<T>;
    toBe<P = T>(value: MaybeRef<T | P>, options?: UntilToMatchOptions): Promise<void>;
    toBeTruthy(options?: UntilToMatchOptions): Promise<void>;
    toBeNull(options?: UntilToMatchOptions): Promise<void>;
    toBeUndefined(options?: UntilToMatchOptions): Promise<void>;
    toBeNaN(options?: UntilToMatchOptions): Promise<void>;
}
interface UntilArrayInstance<T> extends UntilBaseInstance<T> {
    readonly not: UntilArrayInstance<T>;
    toContains(value: MaybeRef<ElementOf<ShallowUnwrapRef<T>>>, options?: UntilToMatchOptions): Promise<void>;
}
/**
 * Promised one-time watch for changes
 *
 * @link https://vueuse.org/until
 * @example
 * ```
 * const { count } = useCounter()
 *
 * await until(count).toMatch(v => v > 7)
 *
 * alert('Counter is now larger than 7!')
 * ```
 */
declare function until<T extends unknown[]>(r: T): UntilArrayInstance<T>;
declare function until<T extends Ref<unknown[]>>(r: T): UntilArrayInstance<T>;
declare function until<T>(r: WatchSource<T>): UntilValueInstance<T>;
declare function until<T>(r: T): UntilValueInstance<T>;
/**
 * @deprecated `when` is renamed to `util`, use `until` instead. This will be removed in next major version.
 */
declare const when: typeof until;

/**
 * Basic counter with utility functions.
 *
 * @link https://vueuse.org/useCounter
 * @param [initialValue=0]
 */
declare function useCounter(initialValue?: number): {
    count: vue_demi.Ref<number>;
    inc: (delta?: number) => number;
    dec: (delta?: number) => number;
    get: () => number;
    set: (val: number) => number;
    reset: (val?: number) => number;
};

declare function useDebounce<T>(value: Ref<T>, ms?: number): Readonly<Ref<T>>;

/**
 * Debounce execution of a function.
 *
 * @param  fn          A function to be executed after delay milliseconds debounced.
 * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return A new, debounce, function.
 */
declare function useDebounceFn<T extends FunctionArgs>(fn: T, ms?: MaybeRef<number>): T;

declare function useInterval(interval?: number, immediate?: boolean): {
    stop: Fn;
    start: Fn;
    isActive: vue_demi.Ref<boolean>;
    pause: Fn;
    resume: Fn;
    counter: vue_demi.Ref<number>;
};

interface IntervalFnReturn extends Pausable {
    /**
     * @deprecated use pause() instead
     */
    stop: Fn;
    /**
     * @deprecated use resume() instead
     */
    start: Fn;
}
/**
 * Wrapper for `setInterval` with controls
 *
 * @param cb
 * @param interval
 * @param immediate
 */
declare function useIntervalFn(cb: Fn, interval?: number, immediate?: boolean): IntervalFnReturn;

interface UseLastChangedOptions<Immediate extends boolean, InitialValue extends number | null | undefined = undefined> extends WatchOptions<Immediate> {
    initialValue?: InitialValue;
}
/**
 * Records the timestamp of the last change
 *
 * @link https://vueuse.org/useLastChanged
 */
declare function useLastChanged(source: WatchSource, options?: UseLastChangedOptions<false>): Ref<number | null>;
declare function useLastChanged(source: WatchSource, options: UseLastChangedOptions<true>): Ref<number>;
declare function useLastChanged(source: WatchSource, options: UseLastChangedOptions<boolean, number>): Ref<number>;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 */
declare function useThrottle<T>(value: Ref<T>, delay?: number): Ref<T>;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @return  A new, throttled, function.
 */
declare function useThrottleFn<T extends FunctionArgs>(fn: T, ms?: MaybeRef<number>, trailing?: boolean): T;

/**
 * Update value after a given time with controls.
 *
 * @param interval
 * @param immediate
 */
declare function useTimeout(interval?: number, immediate?: boolean): {
    ready: vue_demi.Ref<boolean>;
    isActive: vue_demi.Ref<boolean>;
    start: () => void;
    stop: () => void;
};

interface TimeoutFnResult {
    start: Fn$1;
    stop: Fn$1;
    isPending: Ref<boolean>;
    /**
     * @deprecated use `isPending` instead
     */
    isActive: Ref<boolean>;
}
/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param cb
 * @param interval
 * @param immediate
 */
declare function useTimeoutFn(cb: (...args: unknown[]) => any, interval?: number, immediate?: boolean): TimeoutFnResult;

/**
 * A boolean ref with a toggler
 *
 * @link https://vueuse.org/useToggle
 * @param [initialValue=false]
 */
declare function useToggle(value: Ref<boolean>): () => boolean;
declare function useToggle(initialValue?: boolean): [Ref<boolean>, () => boolean];

/**
 * Shorthand for watching value to be truthy
 *
 * @link https://vueuse.js.org/whenever
 */
declare function whenever<T = boolean>(source: WatchSource<T>, cb: Fn, options?: WatchOptions): vue_demi.WatchStopHandle;

export { ConfigurableEventFilter, ConfigurableFlush, ConfigurableFlushSync, ControlledRefOptions, DebouncedWatchOptions, DeepMaybeRef, ElementOf, EventFilter, ExtendRefOptions, Fn, FunctionArgs, FunctionWrapperOptions, IgnorableWatchReturn, IgnoredUpdater, IntervalFnReturn, MapOldSources, MapSources, MaybeRef, Pausable, PausableWatchReturn, Reactify, ReactifyNested, ReactifyObjectOptions, ShallowUnwrapRef, SingletonPromiseReturn, SyncRefOptions, ThrottledWatchOptions, TimeoutFnResult, UntilArrayInstance, UntilBaseInstance, UntilToMatchOptions, UntilValueInstance, UseLastChangedOptions, WatchWithFilterOptions, and, assert, biSyncRef, bypassFilter, clamp, containsProp, controlledComputed, controlledRef, createFilterWrapper, createSingletonPromise, debounceFilter, debouncedWatch, extendRef, get, ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isFunction, isNumber, isObject, isString, isWindow, makeDestructurable, noop, not, now, or, pausableFilter, pausableWatch, promiseTimeout, reactify, reactifyObject, reactivePick, set, syncRef, throttleFilter, throttledWatch, timestamp, tryOnMounted, tryOnUnmounted, until, useCounter, useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchWithFilter, when, whenever };
